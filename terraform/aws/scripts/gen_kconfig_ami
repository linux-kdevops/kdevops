#!/usr/bin/env python3
# ex: set filetype=python:

"""
Retrieve AMI owner and instance information from AWS. Use it to
construct the "compute" Kconfig menu.
"""

import sys
import argparse
import os
import re

from collections import defaultdict
from datetime import datetime, timedelta
from configparser import ConfigParser
from jinja2 import Environment, FileSystemLoader

import boto3
from botocore.exceptions import ClientError, NoCredentialsError


def get_default_region():
    """
    Get the default AWS region from ~/.aws/config file.

    Returns:
        str: Default region or 'us-east-1' if not found
    """
    config_path = os.path.expanduser('~/.aws/config')
    if os.path.exists(config_path):
        try:
            config = ConfigParser()
            config.read(config_path)
            if 'default' in config:
                return config['default'].get('region', 'us-east-1')
            if 'profile default' in config:
                return config['profile default'].get('region', 'us-east-1')
        except Exception as e:
            print(f"Warning: Error reading AWS config file: {e}", file=sys.stderr)
    return 'us-east-1'


def get_known_ami_owners():
    """
    Get dictionary of trusted AMI owners that publish Linux images.

    Please maintain this dictionary sorted alphabetically by key.

    Returns:
        dict: Dictionary of owner information
    """
    return {
        'almalinux': {
            'owner_id': '764336703387',
            'owner_name': 'AlmaLinux',
            'description': 'AlmaLinux',
            'search_patterns': [
                r'AlmaLinux.*',
            ]
        },
        'amazon': {
            'owner_id': '137112412989',
            'owner_name': 'Amazon',
            'description': 'Amazon Linux',
            'search_patterns': [
                r'al2023-ami-.*',  # Amazon Linux 2023
                r'amzn2-ami-.*',   # Amazon Linux 2
                r'amzn-ami-.*',    # Amazon Linux 1
            ]
        },
        'centos': {
            'owner_id': '125523088429',
            'owner_name': 'CentOS',
            'description': 'CentOS Linux (Legacy)',
            'search_patterns': [
                r'CentOS.*',
            ]
        },
        'debian': {
            'owner_id': '136693071363',
            'owner_name': 'Debian',
            'description': 'Debian GNU/Linux',
            'search_patterns': [
                r'debian-.*',
            ]
        },
        'fedora': {
            'owner_id': '125523088429',
            'owner_name': 'Fedora',
            'description': 'Fedora Linux Cloud',
            'search_patterns': [
                r'Fedora-Cloud-.*',
                r'Fedora-.*',
            ]
        },
        'oracle': {
            'owner_id': '131827586825',
            'owner_name': 'Oracle',
            'description': 'Oracle Linux',
            'search_patterns': [
                r'OL.*-.*',
            ]
        },
        'redhat': {
            'owner_id': '309956199498',
            'owner_name': 'RedHat',
            'description': 'Red Hat Enterprise Linux',
            'search_patterns': [
                r'RHEL-.*',
            ]
        },
        'rocky': {
            'owner_id': '792107900819',
            'owner_name': 'Rocky Linux',
            'description': 'Rocky Linux',
            'search_patterns': [
                r'Rocky-.*',
            ]
        },
        'suse': {
            'owner_id': '013907871322',
            'owner_name': 'SUSE',
            'description': 'Suse Linux Enterprise Server',
            'search_patterns': [
                r'suse-sles-.*',
                r'suse-sle-.*',
            ]
        },
        'ubuntu': {
            'owner_id': '099720109477',
            'owner_name': 'Canonical',
            'description': 'Ubuntu',
            'search_patterns': [
                r'ubuntu/images/.*ubuntu-.*',
            ]
        },
    }


def discover_ami_patterns(owner_id, owner_name, search_patterns, region='us-east-1', quiet=False, months_back=12):
    """
    Dynamically discover AMI patterns by scanning recent AMIs for an owner.

    Args:
        owner_id (str): AWS owner account ID
        owner_name (str): Human readable owner name
        search_patterns (list): Regex patterns to filter AMI names
        region (str): AWS region to query
        quiet (bool): Suppress debug messages
        months_back (int): Number of months back to consider for AMI patterns (default: 12)

    Returns:
        dict: Dictionary of discovered AMI patterns and examples
    """
    try:
        if not quiet:
            print(f"Discovering AMI patterns for {owner_name} in {region}...", file=sys.stderr)

        ec2 = boto3.client('ec2', region_name=region)

        # Get all AMIs from this owner
        all_amis = []
        paginator = ec2.get_paginator('describe_images')

        for page in paginator.paginate(
            Owners=[owner_id],
            Filters=[
                {'Name': 'state', 'Values': ['available']},
                {'Name': 'image-type', 'Values': ['machine']},
            ]
        ):
            all_amis.extend(page['Images'])

        if not quiet:
            print(f"Found {len(all_amis)} total AMIs for {owner_name}", file=sys.stderr)

        # Filter AMIs by search patterns
        matching_amis = []
        for ami in all_amis:
            ami_name = ami.get('Name', '')
            for pattern in search_patterns:
                if re.match(pattern, ami_name, re.IGNORECASE):
                    matching_amis.append(ami)
                    break

        if not quiet:
            print(f"Found {len(matching_amis)} matching AMIs after pattern filtering", file=sys.stderr)

        # Filter by time window to focus on recent, actively maintained AMIs
        cutoff_date = (datetime.now() - timedelta(days=30 * months_back)).isoformat()
        recent_amis = [ami for ami in matching_amis if ami['CreationDate'] >= cutoff_date]

        # Fallback: if too few recent AMIs, expand window to use all matching AMIs
        if len(recent_amis) < 5:
            if not quiet:
                print(f"Warning: Only {len(recent_amis)} AMIs in last {months_back} months, "
                      f"using all {len(matching_amis)} matching AMIs", file=sys.stderr)
            recent_amis = matching_amis
        else:
            if not quiet:
                print(f"Using {len(recent_amis)} AMIs from the last {months_back} months", file=sys.stderr)

        # Group AMIs by detected patterns
        pattern_groups = defaultdict(list)

        for ami in recent_amis:
            ami_name = ami.get('Name', '')
            group_key = classify_ami_name(ami_name, owner_name)

            ami_info = {
                'ami_id': ami['ImageId'],
                'name': ami_name,
                'description': ami.get('Description', ''),
                'creation_date': ami['CreationDate'],
                'architecture': ami.get('Architecture', 'Unknown'),
                'virtualization_type': ami.get('VirtualizationType', 'Unknown'),
                'root_device_type': ami.get('RootDeviceType', 'Unknown'),
                'platform_details': ami.get('PlatformDetails', 'Unknown'),
            }

            pattern_groups[group_key].append(ami_info)

        # Sort each group by creation date (newest first) and generate patterns
        discovered_patterns = {}
        for group_key, amis in pattern_groups.items():
            # Sort by creation date, newest first
            sorted_amis = sorted(amis, key=lambda x: x['creation_date'], reverse=True)

            # Generate Terraform-compatible filter pattern from recent AMIs
            terraform_pattern = generate_terraform_pattern(group_key, sorted_amis)

            discovered_patterns[group_key] = {
                'display_name': group_key,
                'ami_count': len(sorted_amis),
                'latest_ami': sorted_amis[0] if sorted_amis else None,
                'sample_amis': sorted_amis[:3],  # Show 3 most recent
                'terraform_filter': terraform_pattern,
                'terraform_example': generate_terraform_example(group_key, terraform_pattern, owner_id)
            }

        return discovered_patterns

    except NoCredentialsError:
        print("Error: AWS credentials not found. Please configure your credentials.", file=sys.stderr)
        return {}
    except ClientError as e:
        print(f"AWS API Error: {e}", file=sys.stderr)
        return {}
    except Exception as e:
        print(f"Unexpected error: {e}", file=sys.stderr)
        return {}


def classify_ami_name(ami_name, owner_name):
    """
    Classify an AMI name into a logical group for pattern generation.

    Args:
        ami_name (str): AMI name
        owner_name (str): Owner name for context

    Returns:
        str: Classification key
    """
    ami_lower = ami_name.lower()

    if 'al2023' in ami_lower:
        return 'Amazon Linux 2023'
    elif 'amzn2' in ami_lower:
        return 'Amazon Linux 2'
    elif 'amzn-ami' in ami_lower:
        return 'Amazon Linux 1'

    elif 'ubuntu' in ami_lower:
        if 'noble' in ami_lower or '24.04' in ami_lower:
            return 'Ubuntu 24.04 LTS'
        elif 'jammy' in ami_lower or '22.04' in ami_lower:
            return 'Ubuntu 22.04 LTS'
        elif 'focal' in ami_lower or '20.04' in ami_lower:
            return 'Ubuntu 20.04 LTS'
        elif 'bionic' in ami_lower or '18.04' in ami_lower:
            return 'Ubuntu 18.04 LTS'
        else:
            version_match = re.search(r'(\d+\.\d+)', ami_name)
            if version_match:
                return f'Ubuntu {version_match.group(1)}'
            return 'Ubuntu (Other)'

    elif 'rhel' in ami_lower:
        if re.search(r'rhel-?10', ami_lower):
            return 'RHEL 10'
        elif re.search(r'rhel-?9', ami_lower):
            return 'RHEL 9'
        elif re.search(r'rhel-?8', ami_lower):
            return 'RHEL 8'
        elif re.search(r'rhel-?7', ami_lower):
            return 'RHEL 7'
        else:
            version_match = re.search(r'rhel-?(\d+)', ami_lower)
            if version_match:
                return f'RHEL {version_match.group(1)}'
            return 'RHEL (Other)'

    elif 'rocky' in ami_lower:
        version_match = re.search(r'rocky-(\d+)', ami_lower)
        if version_match:
            return f'Rocky Linux {version_match.group(1)}'
        return 'Rocky Linux'

    elif 'almalinux' in ami_lower:
        version_match = re.search(r'(\d+)', ami_name)
        if version_match:
            return f'AlmaLinux {version_match.group(1)}'
        return 'AlmaLinux'

    elif 'debian' in ami_lower:
        if re.search(r'debian-?12', ami_lower) or 'bookworm' in ami_lower:
            return 'Debian 12'
        elif re.search(r'debian-?11', ami_lower) or 'bullseye' in ami_lower:
            return 'Debian 11'
        elif re.search(r'debian-?10', ami_lower) or 'buster' in ami_lower:
            return 'Debian 10'
        else:
            version_match = re.search(r'debian-?(\d+)', ami_lower)
            if version_match:
                return f'Debian {version_match.group(1)}'
            return 'Debian (Other)'

    elif 'suse' in ami_lower or 'sles' in ami_lower:
        version_match = re.search(r'(\d+)', ami_name)
        if version_match:
            return f'SUSE Linux Enterprise {version_match.group(1)}'
        return 'SUSE Linux Enterprise'

    elif 'centos' in ami_lower:
        version_match = re.search(r'(\d+)', ami_name)
        if version_match:
            return f'CentOS {version_match.group(1)}'
        return 'CentOS'

    elif 'fedora' in ami_lower:
        version_match = re.search(r'fedora-.*?(\d+)', ami_lower)
        if version_match:
            return f'Fedora {version_match.group(1)}'
        return 'Fedora'

    elif ami_lower.startswith('ol'):
        version_match = re.search(r'ol(\d+)', ami_lower)
        if version_match:
            return f'Oracle Linux {version_match.group(1)}'
        return 'Oracle Linux'

    # Default: use the owner name
    return f'{owner_name} (Other)'


def generate_terraform_pattern(group_key, sample_amis):
    """
    Generate a Terraform-compatible filter pattern from sample AMIs.

    The pattern preserves distinguishing characteristics (like OS identifiers)
    while wildcarding variable parts (version numbers, dates).

    Args:
        group_key (str): Classification key
        sample_amis (list): List of sample AMI info

    Returns:
        str: Terraform filter pattern
    """
    if not sample_amis:
        return ""

    # Analyze common patterns in AMI names
    names = [ami['name'] for ami in sample_amis]

    # Single AMI case
    if len(names) == 1:
        name = names[0]
        pattern = _create_pattern_with_wildcards(name)
        return pattern

    # Multiple AMIs - need to find distinctive pattern
    # Look for parenthetical OS identifiers like "(Ubuntu 20.04)" or "(Amazon Linux 2)"
    os_identifier = _extract_os_identifier(names)

    if os_identifier:
        # Find common prefix before the OS identifier
        prefix = _find_common_prefix_before_marker(names, os_identifier)
        if prefix:
            # Create pattern: "prefix * (OS identifier)*"
            # Wildcard version numbers before OS, preserve OS, wildcard everything after
            return f"{prefix}*{os_identifier}*"

    # Fallback: find common prefix and use it directly
    # This works well for distributions without OS identifiers
    prefix = _find_common_prefix(names)
    if prefix and len(prefix) > 5:  # Only use prefix if it's substantial
        return f"{prefix}*"

    # Last resort: create pattern from first name with wildcards
    return _create_pattern_with_wildcards(names[0])


def _extract_os_identifier(names):
    """
    Extract common OS identifier from AMI names.

    Looks for patterns like "(Ubuntu 20.04)", "(Amazon Linux 2)", etc.

    Args:
        names (list): List of AMI names

    Returns:
        str: Common OS identifier or None
    """
    # Look for parenthetical content that appears in all names
    paren_pattern = re.compile(r'\([^)]+\)')

    # Find all parenthetical matches in first name
    first_matches = paren_pattern.findall(names[0])

    # Check if any of these matches appear in all names
    for match in first_matches:
        if all(match in name for name in names):
            return match

    return None


def _find_common_prefix(names):
    """Find the longest common prefix across all names."""
    if not names:
        return ""

    min_len = min(len(name) for name in names)
    prefix_len = 0

    for i in range(min_len):
        chars = set(name[i] for name in names)
        if len(chars) == 1:
            prefix_len = i + 1
        else:
            break

    return names[0][:prefix_len] if prefix_len > 0 else ""


def _find_common_prefix_before_marker(names, marker):
    """
    Find common prefix that appears before a marker string.

    Args:
        names (list): List of AMI names
        marker (str): Marker string to stop at

    Returns:
        str: Common prefix before marker
    """
    # Extract the part before the marker in each name
    prefixes = []
    for name in names:
        marker_pos = name.find(marker)
        if marker_pos > 0:
            prefixes.append(name[:marker_pos])

    if not prefixes:
        return ""

    return _find_common_prefix(prefixes)


def _create_pattern_with_wildcards(name):
    """
    Create a pattern from a single AMI name by replacing variable parts.

    Args:
        name (str): AMI name

    Returns:
        str: Pattern with wildcards
    """
    pattern = name

    # Replace dates in various formats
    pattern = re.sub(r'\d{8}', '*', pattern)  # 8-digit dates like 20250101
    pattern = re.sub(r'\d{4}-\d{2}-\d{2}', '*', pattern)  # ISO dates like 2025-01-01

    # Replace version numbers (but preserve OS versions in parentheses)
    # Only replace version patterns that are NOT inside parentheses
    # This is tricky, so we'll use a more targeted approach

    # Replace standalone version numbers like "2.3.1" or "1.13"
    # But first, protect parenthetical content
    paren_content = []
    def save_paren(match):
        paren_content.append(match.group(0))
        return f"<<<PAREN{len(paren_content)-1}>>>"

    pattern = re.sub(r'\([^)]+\)', save_paren, pattern)

    # Now replace version numbers outside of parentheses
    pattern = re.sub(r'\s\d+\.\d+(?:\.\d+)?\s', ' * ', pattern)  # Space-delimited versions
    pattern = re.sub(r'-\d+\.\d+(?:\.\d+)?(?=\s|$|-)', '-*', pattern)  # Hyphen-prefixed versions

    # Restore parenthetical content
    for i, content in enumerate(paren_content):
        pattern = pattern.replace(f"<<<PAREN{i}>>>", content)

    # Clean up multiple consecutive wildcards
    pattern = re.sub(r'\*+', '*', pattern)

    return pattern


def generate_terraform_example(group_key, filter_pattern, owner_id):
    """
    Generate a complete Terraform example.

    Args:
        group_key (str): Classification key
        filter_pattern (str): Filter pattern
        owner_id (str): AWS owner account ID

    Returns:
        str: Complete Terraform data source example
    """
    # Create a safe resource name
    resource_name = re.sub(r'[^a-zA-Z0-9_]', '_', group_key.lower())
    resource_name = re.sub(r'_+', '_', resource_name)  # Remove multiple underscores
    resource_name = resource_name.strip('_')  # Remove leading/trailing underscores

    if not filter_pattern:
        filter_pattern = "*"

    terraform_code = f'''data "aws_ami" "{resource_name}" {{
  most_recent = true
  owners      = ["{owner_id}"]
  filter {{
    name   = "name"
    values = ["{filter_pattern}"]
  }}
  filter {{
    name   = "architecture"
    values = ["x86_64"]
  }}
  filter {{
    name   = "virtualization-type"
    values = ["hvm"]
  }}
  filter {{
    name   = "state"
    values = ["available"]
  }}
}}'''

    return terraform_code


def get_owner_ami_info(owners, owner_key, region='us-east-1', quiet=False):
    """
    Get comprehensive AMI information for a specific owner.

    Args:
        owner_key (str): Owner key (e.g., 'amazon', 'ubuntu')
        region (str): AWS region to query
        quiet (bool): Suppress debug messages

    Returns:
        dict: Owner information with discovered AMI patterns
    """
    if owner_key not in owners:
        return None

    owner_info = owners[owner_key].copy()

    discovered_patterns = discover_ami_patterns(
        owner_info['owner_id'],
        owner_info['owner_name'],
        owner_info['search_patterns'],
        region,
        quiet
    )

    owner_info['discovered_patterns'] = discovered_patterns
    owner_info['total_pattern_count'] = len(discovered_patterns)

    return owner_info


def output_ami_menu_kconfig(owners, region):
    """Output the ami menu in kconfig format."""
    environment = Environment(
        loader=FileSystemLoader(sys.path[0]),
        trim_blocks=True,
        lstrip_blocks=True,
    )
    template = environment.get_template("owners.j2")
    print(
        template.render(
            sorted_keys=owners.keys(),
            owners=owners,
        )
    )
    template = environment.get_template("distro.j2")
    for owner_key in owners.keys():
        owner_info = get_owner_ami_info(owners, owner_key, region, True)
        print()
        print(
            template.render(
                owner_name=owner_info['owner_name'].upper().replace(' ', '_'),
                owner_id=owner_info['owner_id'],
                owner_description=owner_info['description'],
                discovered=sorted(owner_info['discovered_patterns'].items()),
            )
        )


def output_owners_kconfig(owners):
    """Output results in kconfig format."""
    environment = Environment(
        loader=FileSystemLoader(sys.path[0]),
        trim_blocks=True,
        lstrip_blocks=True,
    )
    template = environment.get_template("owners.j2")
    print(
        template.render(
            sorted_keys=owners.keys(),
            owners=owners,
        )
    )


def output_owners_raw(owners, quiet=False):
    """Output AMI owners in table format."""
    if not quiet:
        print(f"Known Linux AMI owners ({len(owners)}):\n")

    print(f"{'Owner Key':<12} {'Owner Name':<15} {'Owner ID':<15} {'Description':<30}")
    print("-" * 75)

    for owner_key in owners.keys():
        owner = owners[owner_key]
        print(f"{owner_key:<12} "
              f"{owner['owner_name']:<15} "
              f"{owner['owner_id']:<15} "
              f"{owner['description']:<30}")


def output_owner_kconfig(owner_info):
    """Output owner AMI information in kconfig format."""
    environment = Environment(
        loader=FileSystemLoader(sys.path[0]),
        trim_blocks=True,
        lstrip_blocks=True,
    )
    template = environment.get_template("distro.j2")
    print(
        template.render(
            owner_name=owner_info['owner_name'].upper().replace(' ', '_'),
            owner_id=owner_info['owner_id'],
            owner_description=owner_info['description'],
            discovered=sorted(owner_info['discovered_patterns'].items()),
        )
    )


def output_owner_raw(owner_info, quiet=False):
    """Output owner AMI information in table format."""
    if not quiet:
        print(f"AMI Information for {owner_info['owner_name']} (Owner ID: {owner_info['owner_id']})")
        print(f"Description: {owner_info['description']}")
        print(f"Found {owner_info['total_pattern_count']} AMI pattern groups\n")

    if not owner_info['discovered_patterns']:
        print("No AMI patterns discovered for this owner in the specified region.")
        return

    for pattern_name, pattern_info in sorted(owner_info['discovered_patterns'].items()):
        print(f"Pattern: {pattern_name}")
        print(f"  AMI Count: {pattern_info['ami_count']}")
        print(f"  Filter Pattern: {pattern_info['terraform_filter']}")

        if pattern_info['latest_ami']:
            latest = pattern_info['latest_ami']
            print(f"  Latest AMI: {latest['ami_id']} ({latest['creation_date'][:10]})")
            print(f"  Architecture: {latest['architecture']}")

        if pattern_info['sample_amis']:
            print(f"  Sample AMIs:")
            for ami in pattern_info['sample_amis']:
                print(f"    {ami['ami_id']} - {ami['name'][:60]}{'...' if len(ami['name']) > 60 else ''}")
                print(f"      Created: {ami['creation_date'][:10]} | Arch: {ami['architecture']} | Virt: {ami['virtualization_type']}")

        print()


def output_owner_terraform(owner_info):
    """Output owner information as Terraform examples."""
    print(f"# Terraform aws_ami data source examples for {owner_info['owner_name']}")
    print(f"# Owner ID: {owner_info['owner_id']}")
    print(f"# {owner_info['description']}")
    print(f"# Found {owner_info['total_pattern_count']} AMI pattern groups")
    print()

    for pattern_name, pattern_info in sorted(owner_info['discovered_patterns'].items()):
        print(f"# {pattern_name} ({pattern_info['ami_count']} AMIs available)")
        if pattern_info['latest_ami']:
            print(f"# Latest: {pattern_info['latest_ami']['ami_id']} ({pattern_info['latest_ami']['creation_date'][:10]})")
        print(pattern_info['terraform_example'])
        print()


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Get AWS AMI owner information and Terraform filter examples',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python %(prog)s --owners
  python %(prog)s amazon
  python %(prog)s ubuntu --format raw
  python %(prog)s redhat --region eu-west-1
        """
    )

    parser.add_argument(
        'owner_key',
        nargs='?',  # Make owner_key optional when using --owners
        help='AMI owner key (e.g., amazon, ubuntu, redhat, debian, suse, centos, rocky, almalinux)'
    )

    parser.add_argument(
        '--format', '-f',
        choices=['kconfig', 'raw', 'terraform'],
        default='kconfig',
        help='Output format (default: kconfig)'
    )
    parser.add_argument(
        '--owners',
        action='store_true',
        help='List all known AMI owners'
    )
    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress informational messages'
    )
    parser.add_argument(
        '--region', '-r',
        help='AWS region (default: from ~/.aws/config or us-east-1)'
    )
    return parser.parse_args()


def main():
    """Main function to run the program."""
    args = parse_arguments()

    owners = get_known_ami_owners()

    if args.owners:
        if args.format == 'kconfig':
            output_owners_kconfig(owners)
        elif args.format == 'terraform':
            print("'--format terraform' is not valid with '--owners'")
            sys.exit(1)
        else:
            output_owners_raw(owners, args.quiet)
        return

    if args.region:
        region = args.region
    else:
        region = get_default_region()

    if args.owner_key:
        if args.owner_key not in owners:
            print(f"Error: Unknown owner key '{args.owner_key}'", file=sys.stderr)
            print(f"Available owners: {', '.join(owners.keys())}", file=sys.stderr)
            sys.exit(1)

        if not args.quiet:
            print(f"Discovering AMI patterns for {args.owner_key} in {region}...", file=sys.stderr)
            print(f"This may take a moment as we scan available AMIs...", file=sys.stderr)

        owner_info = get_owner_ami_info(owners, args.owner_key, region, args.quiet)

        if not owner_info:
            print(f"Could not retrieve AMI information for owner '{args.owner_key}'.", file=sys.stderr)
            sys.exit(1)

        if not owner_info.get('discovered_patterns'):
            print(f"No AMI patterns discovered for owner '{args.owner_key}' in region {region}.", file=sys.stderr)
            print("This may be because the owner has no AMIs in this region or the search patterns need adjustment.", file=sys.stderr)
            sys.exit(1)

        if args.format == 'kconfig':
            output_owner_kconfig(owner_info)
        elif args.format == 'terraform':
            output_owner_terraform(owner_info)
        else:
            output_owner_raw(owner_info, args.quiet)
        return

    output_ami_menu_kconfig(owners, region)


if __name__ == "__main__":
    main()
