---
- name: Install b4
  become: true
  become_method: ansible.builtin.sudo
  ansible.builtin.pip:
    name:
      - b4
  when:
    - target_linux_install_b4 is defined
    - target_linux_install_b4
    - ansible_os_family == "Debian"

- name: Check if target directory exists
  stat:
    path: "{{ target_linux_dir_path }}"
  register: target_directory_stat

- name: Check if .git directory exists in target path
  stat:
    path: "{{ target_linux_dir_path }}/.git"
  register: git_directory_stat
  when:
    - target_directory_stat.stat.exists

- name: Infer that git clone is needed when .git doesn't exist
  set_fact:
    needs_git_clone: true
  when:
    - target_directory_stat.stat.exists
    - not git_directory_stat.stat.exists

- name: Set needs_git_clone when directory doesn't exist
  set_fact:
    needs_git_clone: true
  when:
    - not target_directory_stat.stat.exists

- name: Set needs_git_clone to false when .git exists
  set_fact:
    needs_git_clone: false
  when:
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists

- name: Verify target git ref exists before cloning
  command: "git ls-remote {{ target_linux_git }} {{ target_linux_ref }}"
  register: ref_check
  when:
    - needs_git_clone|bool

- name: Fail if git ref does not exist
  fail:
    msg: |
      Failed to verify git ref '{{ target_linux_ref }}' exists in repository '{{ target_linux_git }}'.

      This typically happens when:
      1. The ref (branch/tag/commit) doesn't exist in the repository
      2. You're using A/B testing with a shallow clone that doesn't contain the required ref
      3. The repository URL is incorrect or inaccessible

      Please verify:
      - The ref '{{ target_linux_ref }}' exists in the repository
      - If using A/B testing with different refs, ensure shallow cloning is disabled
      - The repository URL '{{ target_linux_git }}' is correct and accessible
  when:
    - needs_git_clone|bool
    - ref_check.rc != 0

- name: Check if git tree is dirty
  command: "git -C {{ target_linux_dir_path }} status --porcelain"
  register: git_status
  changed_when: false
  failed_when: false
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists

- name: Fail if git tree has local modifications
  fail:
    msg: |
      Local modifications exist in the destination: {{ target_linux_dir_path }}

      The git tree is dirty with uncommitted changes. This prevents safe git operations.

      To resolve this, you can:
      1. Commit or stash your changes in {{ target_linux_dir_path }}
      2. Reset the tree with: git -C {{ target_linux_dir_path }} reset --hard
      3. Remove the directory and let kdevops clone fresh: rm -rf {{ target_linux_dir_path }}

      Modified files:
      {{ git_status.stdout }}
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists
    - git_status.stdout | length > 0

- name: Clone {{ target_linux_tree }}
  ansible.builtin.git:
    repo: "{{ target_linux_git }}"
    dest: "{{ target_linux_dir_path }}"
    update: true
    depth: "{{ target_linux_shallow_depth }}"
    version: "{{ target_linux_ref }}"
  register: result
  retries: 3
  delay: 5
  until: result is succeeded
  when:
    - needs_git_clone|bool

- name: Get current git ref when git exists but clone wasn't needed
  command: "git -C {{ target_linux_dir_path }} rev-parse HEAD"
  register: current_ref
  changed_when: false
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists

- name: Get target ref SHA
  command: "git -C {{ target_linux_dir_path }} rev-parse {{ target_linux_ref }}"
  register: target_ref_sha
  changed_when: false
  failed_when: false
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists

- name: Fetch updates if target ref doesn't exist locally
  command: "git -C {{ target_linux_dir_path }} fetch origin"
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists
    - target_ref_sha.rc != 0

- name: Try to resolve ref as direct ref after fetch
  command: "git -C {{ target_linux_dir_path }} rev-parse {{ target_linux_ref }}"
  register: target_ref_sha_direct
  changed_when: false
  failed_when: false
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists
    - target_ref_sha.rc != 0

- name: Try to resolve ref as remote branch if direct ref failed
  command: "git -C {{ target_linux_dir_path }} rev-parse origin/{{ target_linux_ref }}"
  register: target_ref_sha_remote
  changed_when: false
  failed_when: false
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists
    - target_ref_sha.rc != 0
    - target_ref_sha_direct.rc != 0

- name: Set resolved ref for checkout
  set_fact:
    resolved_ref: |
      {%- if target_ref_sha.rc == 0 -%}
      {{ target_linux_ref }}
      {%- elif target_ref_sha_direct is defined and target_ref_sha_direct.rc == 0 -%}
      {{ target_linux_ref }}
      {%- elif target_ref_sha_remote is defined and target_ref_sha_remote.rc == 0 -%}
      origin/{{ target_linux_ref }}
      {%- else -%}
      {{ target_linux_ref }}
      {%- endif -%}
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists

- name: Checkout target ref if not on correct ref
  command: "git -C {{ target_linux_dir_path }} checkout {{ resolved_ref | default(target_linux_ref) }}"
  when:
    - not needs_git_clone|bool
    - target_directory_stat.stat.exists
    - git_directory_stat.stat.exists
    - (target_ref_sha.rc == 0 and current_ref.stdout != target_ref_sha.stdout) or
      (target_ref_sha.rc != 0 and (target_ref_sha_direct is defined and target_ref_sha_direct.rc == 0)) or
      (target_ref_sha.rc != 0 and (target_ref_sha_remote is defined and target_ref_sha_remote.rc == 0))

- name: Copy the kernel delta to the builder
  ansible.builtin.template:
    src: "{{ target_linux_extra_patch }}"
    dest: "{{ target_linux_dir_path }}/{{ target_linux_extra_patch }}"
    owner: "{{ data_user }}"
    group: "{{ data_group }}"
    mode: "u=rw,g=r,o=r"
  when:
    - target_linux_extra_patch is defined

- name: Apply the kernel delta on the builder
  # noqa: command-instead-of-module
  ansible.builtin.command:
    cmd: "git am {{ target_linux_extra_patch }}"
    chdir: "{{ target_linux_dir_path }}"
  register: git_am
  changed_when: not git_am.failed
  when:
    - target_linux_extra_patch is defined

- name: Check git user name and email configuration
  when:
    - target_linux_apply_patch_message_id is defined
    - target_linux_apply_patch_message_id | length > 0
    - bootlinux_b4_am_this_host|bool
  block:
    - name: Get the user's git config info
      community.general.git_config_info:
        scope: global
      register: git_user_info

    - name: Set dummy git user email address
      community.general.git_config:
        name: user.email
        scope: global
        value: "user@example.com"
      when:
        - '"user.email" not in git_user_info.config_values'

    - name: Set dummy git user name
      community.general.git_config:
        name: user.name
        scope: global
        value: "Kdevops User"
      when:
        - '"user.name" not in git_user_info.config_values'

- name: Show the message_id
  ansible.builtin.debug:
    msg: "{{ target_linux_apply_patch_message_id }}"
  when:
    - target_linux_apply_patch_message_id is defined

- name: Apply a message patch set
  ansible.builtin.shell:
    chdir: "{{ target_linux_dir_path }}"
    cmd: |
      set -o pipefail
      b4 am -o - {{ target_linux_apply_patch_message_id }} | git am
  register: b4_am
  changed_when: not b4_am.failed
  when:
    - target_linux_apply_patch_message_id is defined
    - target_linux_apply_patch_message_id | length > 0
    - bootlinux_b4_am_this_host|bool

- name: Copy the configuration for kernel {{ target_linux_tree }}
  ansible.builtin.template:
    src: "{{ role_path }}/templates/{{ linux_config }}"
    dest: "{{ target_linux_dir_path }}/.config"
    owner: "{{ data_user }}"
    group: "{{ data_group }}"
    mode: "u=rw,g=r,o=r"

- name: Set the kernel localversion
  ansible.builtin.lineinfile:
    path: "{{ target_linux_dir_path }}/localversion"
    line: "{{ target_linux_localversion }}"
    mode: "u=rw,g=r,o=r"
    create: true
  when:
    - target_linux_localversion is defined
    - target_linux_localversion != ""

- name: Configure kernel {{ target_linux_tree }}
  community.general.make:
    chdir: "{{ target_linux_dir_path }}"
    target: "olddefconfig"
  when:
    - bootlinux_compiler_gcc|bool

- name: Build {{ target_linux_tree }}
  community.general.make:
    chdir: "{{ target_linux_dir_path }}"
    jobs: "{{ ansible_processor_nproc }}"
    target: "all"
  when:
    - bootlinux_compiler_gcc|bool

- name: Configure kernel {{ target_linux_tree }}
  community.general.make:
    chdir: "{{ target_linux_dir_path }}"
    params:
      LLVM: 1
    target: "olddefconfig"
  when:
    - bootlinux_compiler_clang|bool

- name: Build {{ target_linux_tree }}
  community.general.make:
    chdir: "{{ target_linux_dir_path }}"
    jobs: "{{ ansible_processor_nproc }}"
    params:
      LLVM: 1
    target: "all"
  when:
    - bootlinux_compiler_clang|bool

- name: Remove the old artifacts directory on the control host
  delegate_to: localhost
  ansible.builtin.file:
    path: "{{ bootlinux_artifacts_dir }}"
    state: absent

- name: Ensure an empty artifacts directory exists on the control host
  delegate_to: localhost
  run_once: true
  ansible.builtin.file:
    path: "{{ bootlinux_artifacts_dir }}"
    state: directory
    mode: "u=rwx,g=rx,o=rx"

- name: Build kernel .deb packages
  when:
    - ansible_os_family == "Debian"
  block:
    - name: Make the bindeb-pkg target
      community.general.make:
        chdir: "{{ target_linux_dir_path }}"
        jobs: "{{ ansible_processor_nproc }}"
        target: "bindeb-pkg"

    - name: Find the build artifacts
      ansible.builtin.find:
        paths: "{{ artifact_paths }}"
        patterns: "*.deb"
        file_type: file
        recurse: true
      register: found_debs

    - name: Fetch the build artifacts to the control host
      ansible.builtin.fetch:
        src: "{{ item.path }}"
        dest: "{{ bootlinux_artifacts_dir }}/"
        flat: true
      loop: "{{ found_debs.files }}"
      loop_control:
        label: "Fetching {{ item.path | basename }} ..."

- name: Build kernel .rpm packages
  when:
    - ansible_os_family != "Debian"
  block:
    - name: Build the list of artifacts directories on the builder
      ansible.builtin.set_fact:
        artifact_paths:
          - "{{ target_linux_dir_path }}/rpmbuild/RPMS"
          - "{{ ansible_env.HOME }}/rpmbuild/RPMS"

    - name: Wipe the artifact directories on the builder
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ artifact_paths }}"
      loop_control:
        label: "Deleting {{ item }} ..."

    - name: Create empty artifact directories on the builder
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: "u=rwx,g=rx,o=rx"
      loop: "{{ artifact_paths }}"
      loop_control:
        label: "Creating {{ item }} ..."

    - name: Make the binrpm-pkg target
      community.general.make:
        chdir: "{{ target_linux_dir_path }}"
        jobs: "{{ ansible_processor_nproc }}"
        target: "binrpm-pkg"
        params:
          RPMOPTS: '--without devel'
      when:
        - bootlinux_compiler_gcc|bool

    - name: Make the binrpm-pkg target
      community.general.make:
        chdir: "{{ target_linux_dir_path }}"
        jobs: "{{ ansible_processor_nproc }}"
        target: "binrpm-pkg"
        params:
          RPMOPTS: '--without devel'
          LLVM: 1
      when:
        - bootlinux_compiler_clang|bool

    - name: Find the build artifacts
      ansible.builtin.find:
        paths: "{{ artifact_paths }}"
        patterns: "*.rpm"
        file_type: file
        recurse: true
      register: found_rpms

    - name: Fetch the build artifacts to the control host
      ansible.builtin.fetch:
        src: "{{ item.path }}"
        dest: "{{ bootlinux_artifacts_dir }}/"
        flat: true
      loop: "{{ found_rpms.files }}"
      loop_control:
        label: "Fetching {{ item.path | basename }} ..."

- name: Extract the release information of the built kernel
  community.general.make:
    chdir: "{{ target_linux_dir_path }}"
    target: "kernelrelease"
  register: kernelrelease

- name: Store the kernel release information with the build artifacts
  delegate_to: localhost
  ansible.builtin.lineinfile:
    create: true
    line: "{{ kernelrelease.stdout }}"
    mode: "u=rw,g=r,o=r"
    path: "{{ bootlinux_artifacts_dir }}/kernel.release"

- name: Skip the kernel install steps
  ansible.builtin.meta: end_play
