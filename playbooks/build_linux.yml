---
- name: Build Linux Kernel Multiple Times
  hosts: baseline:dev
  vars:
    build_linux_repeat_count: "{{ build_linux_repeat_count | default(100) | int }}"
    build_linux_make_jobs: "{{ build_linux_make_jobs | default(0) | int }}"
    build_linux_target: "{{ build_linux_target | default('all') }}"
    build_linux_clean_between: "{{ build_linux_clean_between | default(false) | bool }}"
    build_linux_collect_stats: "{{ build_linux_collect_stats | default(true) | bool }}"
    build_linux_results_dir: "{{ build_linux_results_dir | default('workflows/build-linux/results') }}"
    build_linux_storage_enable: "{{ build_linux_storage_enable | default(false) | bool }}"
    build_linux_device: "{{ build_linux_device | default('') }}"
    # Note: build_linux_fstype is set dynamically based on node name when multifs testing is enabled
    build_linux_use_latest_tag: "{{ build_linux_use_latest_tag | default(false) | bool }}"
    build_linux_allow_modifications: "{{ build_linux_allow_modifications | default(false) | bool }}"
    shallow_clone: true
    clone_depth: 1

    # Build paths - for build-linux workflow, both source and build are in build filesystem
    linux_source_dir: "{{ data_path }}/build/linux-source"
    linux_build_dir: "{{ data_path }}/build/linux-build"
    # We enable building Linux locally, it'll be easier instead of re-inventing
    # all the kconfig for us to leverage the URL parsing. If you do not want
    # to build and installing Linux on the target nodes, you just skip the
    # make linux target.
    linux_git_url: "{{ bootlinux_tree | default('git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git') }}"

  pre_tasks:
    # Install monitoring dependencies if monitoring is enabled
    - ansible.builtin.import_tasks: roles/monitoring/tasks/install-deps/main.yml
      when:
        - enable_monitoring|default(false)|bool
      tags: ["monitoring", "install_deps"]

  tasks:
    - name: Set initial filesystem type
      set_fact:
        node_fstype: "{{ build_linux_fstype | default('xfs') }}"

    # Dependencies are handled by bootlinux role's install-deps
    - ansible.builtin.import_tasks: roles/bootlinux/tasks/install-deps/main.yml
      tags: ["install_deps"]

    - name: Detect filesystem configuration from node name
      when:
        - build_linux_enable_multifs_testing|default(false)|bool
        - build_linux_multifs_use_node_fs|default(false)|bool
      block:
        - name: Set filesystem type based on node name
          set_fact:
            node_fstype: >-
              {%- if 'xfs' in ansible_hostname -%}xfs
              {%- elif 'ext4' in ansible_hostname -%}ext4
              {%- elif 'btrfs' in ansible_hostname -%}btrfs
              {%- elif 'tmpfs' in ansible_hostname -%}tmpfs
              {%- else -%}{{ build_linux_fstype|default('xfs') }}{%- endif -%}

        - name: Set XFS block and sector sizes from node name
          when: node_fstype == 'xfs'
          set_fact:
            node_xfs_blocksize: >-
              {%- if 'xfs-4k' in ansible_hostname -%}4096
              {%- elif 'xfs-8k' in ansible_hostname -%}8192
              {%- elif 'xfs-16k' in ansible_hostname -%}16384
              {%- elif 'xfs-32k' in ansible_hostname -%}32768
              {%- elif 'xfs-64k' in ansible_hostname -%}65536
              {%- else -%}4096{%- endif -%}
            node_xfs_sectorsize: "4096"

    - name: Setup dedicated build filesystem
      when:
        - build_linux_storage_enable
      block:
        - name: Check if device is already mounted
          become: yes
          ansible.builtin.shell: |
            # Check both the symlink and the actual device
            DEVICE="{{ build_linux_device }}"
            REAL_DEVICE=$(readlink -f "$DEVICE" 2>/dev/null || echo "$DEVICE")
            mount | grep -E "($DEVICE|$REAL_DEVICE)"
          register: mount_check
          failed_when: false
          changed_when: false

        - name: Unmount device if currently mounted
          become: yes
          ansible.builtin.mount:
            path: "{{ data_path }}/build"
            state: unmounted
          when: mount_check.rc == 0

        - name: Create XFS filesystem with custom block and sector sizes
          become: yes
          ansible.builtin.command:
            argv:
              - mkfs.xfs
              - -f
              - -b
              - "size={{ node_xfs_blocksize|default(4096) }}"
              - -s
              - "size={{ node_xfs_sectorsize|default(4096) }}"
              - "{{ build_linux_device }}"
          when: node_fstype == 'xfs'

        - name: Create non-XFS filesystem on device
          become: yes
          ansible.builtin.filesystem:
            fstype: "{{ node_fstype }}"
            dev: "{{ build_linux_device }}"
            force: yes
          when:
            - node_fstype != 'tmpfs'
            - node_fstype != 'xfs'

        - name: Mount build filesystem
          become: yes
          ansible.builtin.mount:
            path: "{{ data_path }}/build"
            src: "{{ build_linux_device if node_fstype != 'tmpfs' else 'tmpfs' }}"
            fstype: "{{ node_fstype }}"
            opts: "{{ 'size=32G' if node_fstype == 'tmpfs' else 'defaults' }}"
            state: mounted

        - name: Set ownership of build directory
          become: yes
          ansible.builtin.file:
            path: "{{ data_path }}/build"
            owner: "{{ ansible_user_id }}"
            group: "{{ ansible_user_gid }}"
            mode: '0755'

    - name: Create build directories
      become: yes
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
        owner: "{{ ansible_user_id }}"
        group: "{{ ansible_user_gid }}"
      loop:
        - "{{ linux_source_dir }}"
        - "{{ linux_build_dir }}"
        - "{{ data_path }}/build-results"

    - name: Check if Linux source exists
      ansible.builtin.stat:
        path: "{{ linux_source_dir }}/.git"
      register: linux_git_exists

    - name: Check if Linux source is valid
      ansible.builtin.command: git rev-parse --git-dir
      args:
        chdir: "{{ linux_source_dir }}"
      register: git_repo_check
      failed_when: false
      changed_when: false
      when: linux_git_exists.stat.exists

    - name: Report git repository status
      ansible.builtin.debug:
        msg: >-
          Git repository: 
          {% if linux_git_exists.stat.exists and git_repo_check.rc == 0 %}Using existing valid repository
          {% elif linux_git_exists.stat.exists and git_repo_check.rc != 0 %}Found corrupted repository, will remove and re-clone
          {% else %}Repository missing, will clone
          {% endif %}

    - name: Remove invalid git repository
      ansible.builtin.file:
        path: "{{ linux_source_dir }}"
        state: absent
      when: 
        - linux_git_exists.stat.exists
        - git_repo_check.rc != 0

    - name: Clone Linux kernel source (shallow)
      ansible.builtin.git:
        repo: "{{ linux_git_url }}"
        dest: "{{ linux_source_dir }}"
        depth: "{{ clone_depth }}"
        single_branch: yes
      when:
        - not linux_git_exists.stat.exists or git_repo_check.rc != 0
        - shallow_clone

    - name: Clone Linux kernel source (full)
      ansible.builtin.git:
        repo: "{{ linux_git_url }}"
        dest: "{{ linux_source_dir }}"
      when:
        - not linux_git_exists.stat.exists or git_repo_check.rc != 0
        - not shallow_clone
      retries: 3
      delay: 10
      register: git_result
      until: not git_result.failed

    - name: Check if linux source directory is writable
      ansible.builtin.stat:
        path: "{{ linux_source_dir }}"
      register: linux_source_stat

    - name: Fetch recent tags for latest tag detection
      ansible.builtin.command: git fetch --depth=10 --tags
      args:
        chdir: "{{ linux_source_dir }}"
      when:
        - build_linux_use_latest_tag
        - linux_source_stat.stat.writeable

    # Start monitoring services right before running builds
    - ansible.builtin.import_tasks: roles/monitoring/tasks/monitor_run.yml
      when:
        - enable_monitoring|default(false)|bool
      tags: ["monitoring", "monitor_run"]

    - name: Ensure /data directory is writable
      ansible.builtin.file:
        path: "{{ data_path }}"
        state: directory
        mode: '0755'
        owner: "{{ ansible_user | default('kdevops') }}"
        group: "{{ ansible_user | default('kdevops') }}"
      become: yes
      become_user: root

    - name: Copy build script
      ansible.builtin.copy:
        src: "{{ playbook_dir }}/../workflows/build-linux/scripts/build_linux.py"
        dest: "{{ data_path }}/build_linux.py"
        mode: '0755'

    - name: Run Linux kernel builds
      ansible.builtin.command: |
        python3 {{ data_path }}/build_linux.py \
          --source-dir {{ linux_source_dir }} \
          --build-dir {{ linux_build_dir }} \
          --results-dir {{ data_path }}/build-results \
          --count {{ build_linux_repeat_count }} \
          --jobs {{ build_linux_make_jobs }} \
          --target {{ build_linux_target }} \
          {% if build_linux_clean_between %}--clean-between{% endif %} \
          {% if build_linux_collect_stats %}--collect-stats{% endif %} \
          {% if build_linux_use_latest_tag and linux_source_stat.stat.writeable %}--use-latest{% else %}--tag {{ build_linux_custom_tag | default('master') }}{% endif %}
      register: build_result
      async: 36000  # 10 hours timeout
      poll: 60  # Check every minute

    - name: Display build output
      ansible.builtin.debug:
        msg: "{{ build_result.stdout_lines }}"
      when: build_result is defined

    - name: Check for build results
      ansible.builtin.stat:
        path: "{{ data_path }}/build-results/summary_{{ ansible_hostname }}.json"
      register: summary_file

    - name: Read and display summary
      when: summary_file.stat.exists
      block:
        - name: Read summary file
          ansible.builtin.slurp:
            src: "{{ data_path }}/build-results/summary_{{ ansible_hostname }}.json"
          register: summary_content

        - name: Parse summary
          ansible.builtin.set_fact:
            build_summary: "{{ summary_content.content | b64decode | from_json }}"

        - name: Display summary statistics
          ansible.builtin.debug:
            msg: |
              Build Statistics Summary
              ========================
              Total builds: {{ build_summary.total_builds }}
              Successful builds: {{ build_summary.successful_builds }}
              Failed builds: {{ build_summary.failed_builds }}
              Average build time: {{ build_summary.statistics.average | round(2) }} seconds
              Median build time: {{ build_summary.statistics.median | round(2) }} seconds
              Min/Max: {{ build_summary.statistics.min | round(2) }}/{{ build_summary.statistics.max | round(2) }} seconds
              Total time: {{ build_summary.statistics.total_hours | round(2) }} hours

  post_tasks:
    # Collect monitoring data after builds complete
    - ansible.builtin.import_tasks: roles/monitoring/tasks/monitor_collect.yml
      when:
        - enable_monitoring|default(false)|bool
      tags: ["monitoring", "monitor_collect"]
