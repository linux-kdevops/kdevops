#!/usr/bin/env python3
#
# Copyright (C) 2025 Luis Chamberlain <mcgrof@kernel.org>
# SPDX-License-Identifier: GPL-2.0-or-later OR copyleft-next-0.3.1

# Generates a Coccinelle file which can be used to track down if a routine
# can sleep up to --max-depth levels (defauilt is 1). You can either specify
# the sleep routine you want to check for, or you can use our built-in db.
# Huge work in progress, but its a start.
#
# This is work in progress.
# Confidence: low

import multiprocessing
import argparse

"""
Generate a Coccinelle semantic patch that checks for atomic context
in any transitive caller (up to N levels) of a target function.
Example usage:
    ./check_for_atomic_calls.py --levels 5 --target __find_get_block_slow --output atomic_check_find_block.cocci
    make coccicheck MODE=report COCCI=find_block_check.cocci
For an obvious atomic call:
    ./check_for_atomic_calls.py --levels 5 --target netif_rx --output netif_rx.cocci
    make coccicheck MODE=report COCCI=netif_rx.cocci
"""
parser = argparse.ArgumentParser(
    description="Generate a Coccinelle checker for atomic context in transitive callers of a target function."
)
parser.add_argument(
    "--levels",
    "-l",
    type=int,
    required=True,
    help="Maximum number of transitive caller levels to follow (e.g., 5)",
)
parser.add_argument(
    "--target",
    "-t",
    type=str,
    required=True,
    help="Target function to trace (e.g., __find_get_block_slow)",
)
parser.add_argument(
    "--output", "-o", type=str, required=True, help="Output .cocci file to generate"
)
args = parser.parse_args()
max_depth = args.levels
target_func = args.target


# Add a function to get the number of processors for parallel jobs
def get_nprocs():
    try:
        return multiprocessing.cpu_count()
    except:
        return 1  # Default to 1 if can't determine


outfile = args.output
header = f"""// SPDX-License-Identifier: GPL-2.0
/// Autogenerated by gen_atomic_context_chain.py
/// Detect atomic context in ANY transitive caller (up to {max_depth} levels)
/// of `{target_func}`
// Options: --no-includes --include-headers
virtual after_start
virtual report
@initialize:python@
@@
seen = set()
seen_atomic = set()
seen_irq_regions = set()
seen_spinlock_regions = set()

def register_caller(fn, file):
    if fn not in seen:
        seen.add(fn)
        it = Iteration()
        if file is not None:
            it.set_files([file])
        it.add_virtual_rule("after_start")
        it.add_virtual_identifier("transitive_caller", fn)
        it.register()

// Look for direct calls to the target function
@seed@
identifier fn;
position p;
@@
fn@p(...) {{
  <+... {target_func}(...); ...+>
}}

@script:python depends on seed@
fn << seed.fn;
p  << seed.p;
@@
print(f"🌱 SEED HIT: {{fn}} calls {target_func} at {{p[0].file}}:{{p[0].line}}")
register_caller(fn, p[0].file)

// Special pattern for IRQ handler detection in macro definitions
@irq_handler_def@
identifier fn;
@@
(
DEFINE_IRQ_HANDLER(fn, ...)
|
DECLARE_TASKLET(fn, ...)
)

@script:python depends on irq_handler_def@
fn << irq_handler_def.fn;
@@
print(f"⚡ DEFINED IRQ HANDLER: {{fn}}")
register_caller(fn, None)

// Look for irq-related function names that haven't been caught yet
@irq_func_names@
identifier fn =~ "(_irq|_intr|_isr|_napi|_poll|_tasklet|_softirq|_bh)$";
@@

fn(...) {{ ... }}

@script:python depends on irq_func_names@
fn << irq_func_names.fn;
@@
print(f"⚡ NAMED IRQ HANDLER: {{fn}}")
register_caller(fn, None)

// Look for functions with interrupt prefix naming patterns
@interrupt_prefixed@
identifier fn =~ "^(irq_|intr_|isr_|napi_|poll_|do_softirq|tasklet_)";
@@

fn(...) {{ ... }}

@script:python depends on interrupt_prefixed@
fn << interrupt_prefixed.fn;
@@
print(f"⚡ PREFIXED IRQ HANDLER: {{fn}}")
register_caller(fn, None)
"""
with open(outfile, "w") as f:
    f.write(header)

    # Generate all the caller chain rules
    for level in range(1, max_depth + 1):
        f.write(
            f"""
// Level {level} caller discovery
@caller{level} depends on after_start exists@
identifier virtual.transitive_caller;
identifier fn;
position p;
@@
fn@p(...) {{
  <+... transitive_caller(...); ...+>
}}

@script:python depends on caller{level}@
fn << caller{level}.fn;
p << caller{level}.p;
transitive_caller << virtual.transitive_caller;
@@
print(f"🔄 Chain level {level}: {{fn}} calls {{transitive_caller}} at {{p[0].file}}:{{p[0].line}}")
register_caller(fn, p[0].file)
"""
        )

    # Check for atomic context in each caller in our chain
    for level in range(1, max_depth + 1):
        # First, check for common atomic primitives
        f.write(
            f"""
// Level {level} atomic context check - Common atomic primitives
@atomiccheck{level} depends on after_start exists@
identifier virtual.transitive_caller;
position p1, p2;
@@
(
spin_lock@p1(...)
|
spin_lock_irq@p1(...)
|
spin_lock_irqsave@p1(...)
|
spin_lock_bh@p1(...)
|
read_lock@p1(...)
|
read_lock_irq@p1(...)
|
read_lock_irqsave@p1(...)
|
read_lock_bh@p1(...)
|
write_lock@p1(...)
|
write_lock_irq@p1(...)
|
write_lock_irqsave@p1(...)
|
write_lock_bh@p1(...)
|
raw_spin_lock@p1(...)
|
raw_spin_lock_irq@p1(...)
|
raw_spin_lock_irqsave@p1(...)
|
raw_spin_lock_bh@p1(...)
|
local_irq_disable@p1()
|
local_irq_save@p1(...)
|
local_bh_disable@p1()
|
preempt_disable@p1()
|
in_atomic@p1()
|
in_atomic_preempt_off@p1()
|
in_interrupt@p1()
|
in_irq@p1()
|
in_serving_softirq@p1()
|
in_nmi@p1()
|
in_task@p1()
|
rcu_read_lock@p1()
|
irq_enter@p1()
|
napi_disable@p1(...)
)
...
transitive_caller@p2(...)

@script:python depends on atomiccheck{level}@
p1 << atomiccheck{level}.p1;
p2 << atomiccheck{level}.p2;
transitive_caller << virtual.transitive_caller;
@@
key = (p1[0].file, p1[0].line, transitive_caller)
if key not in seen_atomic:
    seen_atomic.add(key)
    print(f"⚠️  WARNING: atomic context at level {level}: {{p1[0].current_element}} at {{p1[0].file}}:{{p1[0].line}} may reach {{transitive_caller}}() → eventually {target_func}()")
"""
        )

        # Check for lock-related functions directly calling our chain
        f.write(
            f"""
// Level {level} atomic context check - Lock-related functions
@atomic_fn_check{level} depends on after_start exists@
identifier virtual.transitive_caller;
identifier lock_fn;
position p;
@@
// Common locking function patterns
lock_fn(...) {{
  ... when != unlock_irqrestore(...)
      when != local_irq_restore(...)
      when != spin_unlock(...)
      when != rcu_read_unlock(...)
  transitive_caller@p(...)
  ...
}}

@script:python depends on atomic_fn_check{level}@
lock_fn << atomic_fn_check{level}.lock_fn;
p << atomic_fn_check{level}.p;
transitive_caller << virtual.transitive_caller;
@@
# Only report functions with lock-related names
atomic_keywords = ['lock', 'irq', 'atomic', 'bh', 'intr', 'preempt', 'disable', 'napi', 'rcu']
if any(kw in lock_fn.lower() for kw in atomic_keywords):
    print(f"⚠️  WARNING: potential atomic function at level {level}: {{lock_fn}} (name suggests lock handling) contains call to {{transitive_caller}}() at {{p[0].file}}:{{p[0].line}} → eventually {target_func}()")
"""
        )

        # Check for spinlock regions
        f.write(
            f"""
// Level {level} spinlock region check
@spinlock_region{level} depends on after_start exists@
identifier virtual.transitive_caller;
expression E1, flags;
position p1, p3;
@@
(
spin_lock@p1(E1,...)
|
spin_lock_irq@p1(E1,...)
|
spin_lock_irqsave@p1(E1, flags)
|
spin_trylock@p1(E1)
|
raw_spin_lock@p1(E1,...)
|
raw_spin_lock_irq@p1(E1,...)
|
raw_spin_lock_irqsave@p1(E1, flags)
|
raw_spin_trylock@p1(E1)
)
... when != spin_unlock(E1,...)
    when != spin_unlock_irq(E1,...)
    when != spin_unlock_irqrestore(E1, flags)
    when != raw_spin_unlock(E1,...)
    when != raw_spin_unlock_irq(E1,...)
    when != raw_spin_unlock_irqrestore(E1, flags)
transitive_caller@p3(...)

@script:python depends on spinlock_region{level}@
p1 << spinlock_region{level}.p1;
p3 << spinlock_region{level}.p3;
transitive_caller << virtual.transitive_caller;
@@
key = (p1[0].file, p1[0].line, p3[0].line, transitive_caller)
if key not in seen_spinlock_regions:
    seen_spinlock_regions.add(key)
    print(f"⚠️  WARNING: spinlock region at level {level}: {{p1[0].current_element}} at {{p1[0].file}}:{{p1[0].line}} contains call to {{transitive_caller}}() at line {{p3[0].line}} → eventually {target_func}()")
"""
        )

        # Look for functions that can't sleep
        f.write(
            f"""
// Level {level} check - Can't sleep contexts
@cant_sleep{level} depends on after_start exists@
identifier virtual.transitive_caller;
position p1, p2;
@@
(
GFP_ATOMIC@p1
|
cond_resched@p1()
|
__GFP_ATOMIC@p1
|
DECLARE_COMPLETION@p1(...)
)
...
transitive_caller@p2(...)

@script:python depends on cant_sleep{level}@
p1 << cant_sleep{level}.p1;
p2 << cant_sleep{level}.p2;
transitive_caller << virtual.transitive_caller;
@@
print(f"⚠️  WARNING: Non-sleeping context at {{p1[0].file}}:{{p1[0].line}} but calls {{transitive_caller}}() at line {{p2[0].line}} → eventually {target_func}()")
"""
        )

        # Check for network driver contexts
        f.write(
            f"""
// Level {level} check - Network driver contexts (commonly atomic)
@netdriver{level} depends on after_start exists@
identifier virtual.transitive_caller;
position p1, p2;
@@
(
alloc_skb@p1(...)
|
netif_receive_skb@p1(...)
|
netdev_alloc_skb@p1(...)
|
napi_complete@p1(...)
|
napi_schedule@p1(...)
|
napi_gro_receive@p1(...)
|
skb_reserve@p1(...)
|
consume_skb@p1(...)
|
dev_consume_skb_any@p1(...)
|
skb_put@p1(...)
|
skb_push@p1(...)
|
netif_rx_ni@p1(...)
)
...
transitive_caller@p2(...)

@script:python depends on netdriver{level}@
p1 << netdriver{level}.p1;
p2 << netdriver{level}.p2;
transitive_caller << virtual.transitive_caller;
@@
print(f"⚠️  WARNING: Network driver context at {{p1[0].file}}:{{p1[0].line}} but calls {{transitive_caller}}() at line {{p2[0].line}} → eventually {target_func}()")
"""
        )

        # Check for functions that might call from atomic context by name
        f.write(
            f"""
// Level {level} check - Function with name suggesting atomic context
@atomic_name{level} depends on after_start exists@
identifier virtual.transitive_caller;
identifier atomic_fn =~ "(_irq|_intr|_isr|_napi|_poll|_bh|_softirq|_tasklet|_atomic)$";
position p;
@@
atomic_fn(...) {{
...
transitive_caller@p(...)
...
}}

@script:python depends on atomic_name{level}@
atomic_fn << atomic_name{level}.atomic_fn;
p << atomic_name{level}.p;
transitive_caller << virtual.transitive_caller;
@@
print(f"⚠️  WARNING: Function with atomic-suggesting name {{atomic_fn}} calls {{transitive_caller}}() at {{p[0].file}}:{{p[0].line}} → eventually {target_func}()")
"""
        )

        # Check for sleep-incompatible contexts but target function might sleep
        f.write(
            f"""
// Level {level} check - Target function called in context where might_sleep is used
@might_sleep_check{level} depends on after_start exists@
identifier virtual.transitive_caller;
position p1, p2;
@@
(
might_sleep@p1()
|
might_sleep_if@p1(...)
|
sched_might_sleep@p1()
) 
...
transitive_caller@p2(...)

@script:python depends on might_sleep_check{level}@
p1 << might_sleep_check{level}.p1;
p2 << might_sleep_check{level}.p2;
transitive_caller << virtual.transitive_caller;
@@
print(f"⚠️  WARNING: Function has might_sleep() at {{p1[0].file}}:{{p1[0].line}} but also calls {{transitive_caller}}() at line {{p2[0].line}} → eventually {target_func}()")
"""
        )

    f.write("\n")

print(
    f"✅ Generated {outfile} with enhanced atomic checks for `{target_func}` up to {max_depth} levels. Run with: make coccicheck MODE=report COCCI={outfile} J={get_nprocs()}"
)
